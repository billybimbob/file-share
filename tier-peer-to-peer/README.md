# Async Tiered Peer-to-Peer Downloader

This project creates creates a peer-to-peer downloading file system, which is based on the [Python asyncio](https://docs.python.org/3/library/asyncio.html) package, specifically with the cooperative multitasking style. All socket communication and concurrency was (mostly) done with async tasks instead of threads.

## Requirements

The required minimum version is **Python 3.9**

All of the modules utilized in this project, besides the matplotlib library for graphing, are part of the standard Python library. As a result from the lack of 3rd party libraries, as well as Python being an interpreted language, there is no Makefile.

### Docker

All the requirements, including the graphing capabilities can be initialized in a docker container:

1. Create the docker image:

    ```bash
    docker build -t p2p .
    ```

2. Create a new container and run a new shell:

    ```bash
    docker run -it --rm p2p /bin/bash
    ```

3. All commands specified below can be called in the container shell

## Running

The project comprises of three main components:

* `strongpeer.py`: creates an indexing server
* `weakpeer.py`: creates peers
* `evaluation.py`: runs various server-client configurations and times performance

In order to run any of the above scripts run in the terminal the following command:

```bash
{./strongpeer.py | ./weakpeer.py | ./scripts/evaluation.py} [ARGS...]
```

Each of the scripts have their unique arguments which can be viewed by passing in the `-h` argument.

Both `strongpeer.py` and `weakpeer.py` can both take in a configuration file instead of just command line arguments. The expected file format is an [INI file](https://en.wikipedia.org/wiki/INI_file). View the sample configuration files in `configs` folder. A mix of command line arguments and configuration file can also be applied, with the configuration file overriding any duplicate args:

```bash
{./strongpeer.py | ./weakpeer.py} -c CONFIG_FILE [ARGS...]
```

### Indexer/Peer

Running the script `strongpeer.py` and `weakpeer.py` are the actual server-client program, and they work in conjunction with each other. In order to run:

1. Run the `strongpeer.py` script with some specified arguments
2. Wait for the strongpeer to initialize
3. Run `weakpeer.py` any amount of times, making sure that args like `address` reference the location of the strongpeer, and that the `port` number is unique (if multiple peers are running on the same machine)
4. Wait for the peer to initialize, start typing and interacting with either of the strongpeer or peer clis


A peer has its file directory specified, but the exposed directory cannot show nested directories. Also make sure that peer directories are not the same as other peers on the same machine when specifying args.

### Evaluation

The `evaluation.py` script automates much of the initialization steps listed above, with an assumption of the directory structure listed below. When ran, the folder `peers` is created and populated, which are the peer directories.

The main purpose of this script is to time the performance of the peer-peer and peer-strongpeer communication in different configuration contexts. The process to running the evaluations is simply running the script as specified above while supplying the args.

#### Log Generation

For convenience, all of the generated log files can be retested by using the bash script `eval-loop.sh`, which runs evaluations on multiple run configurations:

```bash
./scripts/eval-loop.sh
```

#### Directory Structure

Multiple extra directories were introduced for organization sake. All of the folders below are specified to be run with `evaluation.py` and can also be demos for `strongpeer.py` and `weakpeer.py`:

1. **configs**: some predefined configuration files for testing and evaluation
2. **logs**: the output files while running either `strongpeer.py` or `weakpeer.py`
    * The logs are divided into two folders `download` and `response`, where the former are the logs for the variable file sizes, while the latter is the variable number of peers
    * The naming scheme of each of the log folders indicates configuration the log was ran with:

        ```bash
        {NUMBER_OF_CLIENTS}c{FILE_SIZE}f
        ```

3. **servers**: files that can be hosted and distributed by the peers

    * Each of the server folders are divided by file size

4. **times**: raw and aggregate recordings of peer configuration runtimes, which are generated by `plot_times.py`

### Visualization/Graphing

While not required to run the server and clients, another script, `plot_times.py` generates graphs based on the generated log files. Running the script is in similar fashion to the above programs:

```bash
./scripts/plot_times.py [ARGS...]
```

All of the parsed and generated output are stored in the `times` directory

#### Install dependencies

Note: this dependency is only required for optional script `plot_times.py`:

```bash
pip3 install matplotlib
```

The dependencies are already installed if ran in the docker container.
